<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Countdown — Bomb Viewer</title>
<style>
  :root{
    --bg: #0f1115;
    --fg: #e7e9ee;
    --muted: #8e95a3;
    --bomb: #1f2430;
    --bomb-hl: #2b3242;
    --fuse: #caa46a;
    --spark: #ffcc33;
    --danger: #ff3b3b;
    --ok: #52ffa8;
    --accent: #7aa2ff;
  }
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--fg);
    font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial;
    display:flex; align-items:center; justify-content:center;
    padding:24px;
  }
  .wrap{ max-width: 900px; width:100%; display:grid; gap:16px; justify-items:center; text-align:center; }
  h1{ margin:0; font-size: clamp(18px, 2.2vw, 24px); font-weight:700; }
  .desc{ color: var(--muted); font-size: 14px; max-width: 640px; }
  .timer{ font-size: clamp(32px, 6vw, 56px); font-weight: 800; letter-spacing: 1px; }
  .meta{ color: var(--muted); font-size: 12px; }
  .stage{ width:min(90vw,560px); aspect-ratio: 1 / 1; position:relative; }
  svg{ width:100%; height:100%; display:block; }
  .spark{
    filter: drop-shadow(0 0 6px var(--spark)) drop-shadow(0 0 16px var(--spark));
    transform-origin: center;
    animation: flick 0.25s infinite alternate ease-in-out;
  }
  @keyframes flick { from{ opacity:.85; transform: scale(1);} to{ opacity:1; transform: scale(1.12);} }

  /* BOOM overlay */
  .boom{
    position:absolute; inset:0; display:none; place-items:center; background: transparent;
  }
  .boom.active{ display:grid; animation: shake 0.35s ease-in-out 2; }
  .flash{
    position:absolute; inset:0; border-radius:50%;
    background: radial-gradient(circle at center, rgba(255,255,255,.95), rgba(255,200,0,.85) 35%, rgba(255,0,0,.6) 60%, rgba(0,0,0,0) 70%);
    transform: scale(0); animation: explode 0.7s ease-out forwards;
  }
  .boomText{
    position:relative; z-index:2; font-size: clamp(28px, 7vw, 72px); font-weight: 900; color: var(--danger);
    text-shadow: 0 2px 0 #000, 0 0 24px rgba(255,59,59,.6);
    letter-spacing: 2px;
  }
  @keyframes explode { to { transform: scale(2.2); opacity:0; } }
  @keyframes shake {
    0%,100% { transform: translate(0,0); }
    20% { transform: translate(3px,-2px) rotate(-0.5deg); }
    40% { transform: translate(-3px,2px) rotate(0.5deg); }
    60% { transform: translate(2px,3px) rotate(0.3deg); }
    80% { transform: translate(-2px,-3px) rotate(-0.3deg); }
  }

  .hidden{ display:none !important; }
  .sr { position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden; }
</style>
</head>
<body>
<div class="wrap">
  <h1 id="title">Loading…</h1>
  <div class="desc" id="text"></div>

  <div class="stage" aria-hidden="true">
    <!-- Escena SVG: bomba + mecha -->
    <svg viewBox="0 0 800 800" role="img" aria-label="Bomb with burning fuse">
      <!-- Mecha (curva) -->
      <path id="fusePath" d="M 500 280 C 560 200, 700 200, 720 300
                             C 740 410, 620 420, 590 360
                             C 560 300, 500 330, 470 380
                             C 450 410, 420 420, 390 420"
            fill="none" stroke="var(--fuse)" stroke-width="10" stroke-linecap="round" />

      <!-- Chispa -->
      <g id="spark" class="spark">
        <circle r="10" fill="var(--spark)"></circle>
        <circle r="4" fill="#fff"></circle>
      </g>

      <!-- Bomba (cuerpo) -->
      <defs>
        <radialGradient id="bombGrad" cx="60%" cy="40%">
          <stop offset="0%" stop-color="var(--bomb-hl)"/>
          <stop offset="100%" stop-color="var(--bomb)"/>
        </radialGradient>
      </defs>
      <circle id="bomb" cx="360" cy="520" r="180" fill="url(#bombGrad)" />
      <!-- Brillo -->
      <circle cx="430" cy="460" r="40" fill="rgba(255,255,255,0.08)" />
      <!-- Mecha conectada a la bomba -->
      <rect x="370" y="330" width="20" height="40" rx="6" fill="#6b4f2d"/>

      <!-- Humo suave (decorativo) -->
      <g opacity="0.08">
        <circle cx="500" cy="280" r="18" fill="#fff"/>
        <circle cx="520" cy="260" r="10" fill="#fff"/>
        <circle cx="540" cy="270" r="14" fill="#fff"/>
      </g>
    </svg>

    <!-- Overlay de explosión -->
    <div id="boom" class="boom">
      <div class="flash"></div>
      <div class="boomText">BOOM!</div>
    </div>
  </div>

  <div class="timer" id="timer">--:--:--</div>
  <div class="meta" id="status" aria-live="polite"></div>
  <div class="sr" id="sr-live" aria-live="assertive"></div>
</div>

<script>
/* Utilidades de codificación base64url (mismo formato que tu editor) */
function b64uDecode(b64){
  try{
    const s = atob(b64.replace(/-/g,'+').replace(/_/g,'/'));
    return JSON.parse(decodeURIComponent(escape(s)));
  }catch(e){ return null; }
}
function pad(n){ return String(n).padStart(2,'0'); }

(function(){
  const hash = location.hash.slice(1);
  if(!hash){
    document.getElementById('title').innerText = "No countdown data";
    document.getElementById('text').innerText = "Open a link generated by the editor.";
    document.querySelector('.stage').classList.add('hidden');
    return;
  }
  const data = b64uDecode(hash);
  if(!data){
    document.getElementById('title').innerText = "Invalid link";
    document.querySelector('.stage').classList.add('hidden');
    return;
  }

  const titleEl = document.getElementById('title');
  const textEl  = document.getElementById('text');
  titleEl.innerText = data.title || "Contest countdown";
  textEl.innerText  = data.text  || "Solve the challenge before the fuse burns out!";

  // Determinar inicio (igual que en tu viewer previo)
  const key = 'count:'+hash;
  let firstOpen;
  if(data.mode === 'firstAccessClient'){
    const existing = localStorage.getItem(key);
    firstOpen = existing ? Number(existing) : Date.now();
    if(!existing) localStorage.setItem(key, String(firstOpen));
  } else if(data.mode === 'absolute'){
    firstOpen = data.createdAt || Date.now();
  } else {
    // fallback: per-browser
    const existing = localStorage.getItem(key);
    firstOpen = existing ? Number(existing) : Date.now();
    if(!existing) localStorage.setItem(key, String(firstOpen));
  }

  const lifetime = Number(data.lifetime_ms) || 0;
  const expiresAt = firstOpen + lifetime;

  // Referencias SVG
  const fuse = document.getElementById('fusePath');
  const spark = document.getElementById('spark');
  const bomb = document.getElementById('bomb');
  const boom = document.getElementById('boom');

  // Preparar la mecha: usaremos stroke-dashoffset para “consumirla”
  const totalLen = fuse.getTotalLength();
  fuse.style.strokeDasharray = totalLen;
  fuse.style.strokeDashoffset = 0; // 0 = completa; aumenta hasta totalLen a medida que se consume

  // Actualización de UI
  const timerEl = document.getElementById('timer');
  const statusEl = document.getElementById('status');
  const liveEl = document.getElementById('sr-live');

  let ended = false;
  function formatRemaining(ms){
    const d = Math.floor(ms / 86400000);
    const h = Math.floor(ms % 86400000 / 3600000);
    const m = Math.floor(ms % 3600000 / 60000);
    const s = Math.floor(ms % 60000 / 1000);
    const hh = pad(h), mm = pad(m), ss = pad(s);
    return (d>0? d+'d ':'') + `${hh}:${mm}:${ss}`;
  }

  function tick(){
    const now = Date.now();
    const remaining = Math.max(0, expiresAt - now);

    // Texto
    if(remaining <= 0){
      if(!ended){
        ended = true;
        timerEl.textContent = "00:00:00";
        statusEl.textContent = "Time is up.";
        liveEl.textContent = "Countdown finished.";
        // Animación BOOM
        bomb.style.opacity = 0;
        boom.classList.add('active');
        // Oculta mecha y chispa
        fuse.style.opacity = 0.1;
        spark.style.display = 'none';
      }
      return; // detener animación visual (dejar boom activo)
    } else {
      timerEl.textContent = formatRemaining(remaining);
      statusEl.textContent = `Expires at: ${new Date(expiresAt).toLocaleString()}`;
    }

    // Progreso [0..1]
    const progress = 1 - (remaining / lifetime); // 0 al inicio, 1 al final
    const dash = Math.min(totalLen, Math.max(0, totalLen * progress));
    fuse.style.strokeDashoffset = dash;

    // Mover chispa a lo largo de la mecha (desde inicio hacia fin)
    const point = fuse.getPointAtLength(Math.min(totalLen, dash));
    spark.setAttribute('transform', `translate(${point.x}, ${point.y})`);

    requestAnimationFrame(tick);
  }

  // Inicia la animación
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
